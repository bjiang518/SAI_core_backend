//\n//  OptimizedNetworkService.swift\n//  StudyAI\n//\n//  Fully optimized network service integrating all improvements\n//\n\nimport Foundation\nimport Combine\nimport Network\n\nclass OptimizedNetworkService: ObservableObject {\n    static let shared = OptimizedNetworkService()\n    \n    // MARK: - Core Dependencies\n    private let errorManager = ErrorManager.shared\n    private let performanceManager = PerformanceManager.shared\n    private let stateManager = AppStateManager.shared\n    \n    // MARK: - Network Configuration\n    private let baseURL = \"https://sai-backend-production.up.railway.app\"\n    private let cache = URLCache(memoryCapacity: 50 * 1024 * 1024, diskCapacity: 200 * 1024 * 1024)\n    \n    // MARK: - Advanced Request Management\n    private let requestManager = RequestManager()\n    private let responseProcessor = ResponseProcessor()\n    \n    // MARK: - State Management\n    @Published var isOnline = true\n    @Published var currentSessionId: String?\n    \n    private init() {\n        setupAdvancedNetworking()\n        setupPerformanceMonitoring()\n    }\n    \n    private func setupAdvancedNetworking() {\n        // Configure URLSession with optimal settings\n        let config = URLSessionConfiguration.default\n        config.urlCache = cache\n        config.requestCachePolicy = .useProtocolCachePolicy\n        config.timeoutIntervalForRequest = 30\n        config.timeoutIntervalForResource = 60\n        config.waitsForConnectivity = true\n        config.allowsCellularAccess = true\n        \n        // HTTP/2 and connection optimization\n        config.httpMaximumConnectionsPerHost = 6\n        config.httpShouldUsePipelining = true\n        \n        requestManager.configure(with: config)\n    }\n    \n    private func setupPerformanceMonitoring() {\n        // Monitor network performance\n        NotificationCenter.default.addObserver(\n            forName: .performanceMemoryWarning,\n            object: nil,\n            queue: .main\n        ) { [weak self] _ in\n            self?.handleMemoryPressure()\n        }\n    }\n    \n    // MARK: - Optimized API Methods\n    \n    func submitQuestion(question: String, subject: String = \"general\") async -> (success: Bool, answer: String?) {\n        let result = await errorManager.handle({\n            return try await self.performQuestionSubmission(question: question, subject: subject)\n        }, errorContext: \"Question Submission\", retryKey: \"submit_question\")\n        \n        switch result {\n        case .success(let response):\n            return (true, response.answer)\n        case .failure(let error):\n            await MainActor.run {\n                self.stateManager.updateState(\\.errorMessage, value: error.localizedDescription)\n            }\n            return (false, nil)\n        }\n    }\n    \n    private func performQuestionSubmission(question: String, subject: String) async throws -> QuestionResponse {\n        let requestData = [\n            \"question\": question,\n            \"subject\": subject,\n            \"optimization_level\": \"high\",\n            \"response_format\": \"structured\"\n        ]\n        \n        let response: QuestionResponse = try await requestManager.performOptimizedRequest(\n            endpoint: \"/api/ai/process-question\",\n            method: .POST,\n            body: requestData,\n            cachePolicy: .reloadIgnoringLocalCacheData\n        )\n        \n        return response\n    }\n    \n    func uploadImageForAnalysis(imageData: Data, subject: String = \"general\") async -> (success: Bool, result: [String: Any]?) {\n        // Pre-process image for optimal upload\n        let optimizedImage = await imageProcessor.optimizeForUpload(imageData)\n        \n        let result = await errorManager.executeWithCircuitBreaker({\n            try await self.performImageUpload(imageData: optimizedImage, subject: subject)\n        }, circuitKey: \"image_upload\")\n        \n        switch result {\n        case .success(let response):\n            return (true, response)\n        case .failure:\n            return (false, nil)\n        }\n    }\n    \n    private func performImageUpload(imageData: Data, subject: String) async throws -> [String: Any] {\n        return try await requestManager.performMultipartUpload(\n            endpoint: \"/api/ai/analyze-image\",\n            imageData: imageData,\n            parameters: [\"subject\": subject]\n        )\n    }\n    \n    // MARK: - Session Management\n    \n    func createOptimizedSession(subject: String) async -> (success: Bool, sessionId: String?, message: String) {\n        let result = await errorManager.handle({\n            try await self.performSessionCreation(subject: subject)\n        }, errorContext: \"Session Creation\", retryKey: \"create_session\")\n        \n        switch result {\n        case .success(let sessionData):\n            await MainActor.run {\n                self.currentSessionId = sessionData.sessionId\n            }\n            return (true, sessionData.sessionId, sessionData.message)\n        case .failure(let error):\n            return (false, nil, error.localizedDescription ?? \"Failed to create session\")\n        }\n    }\n    \n    private func performSessionCreation(subject: String) async throws -> SessionCreationResponse {\n        let requestData = [\"subject\": subject]\n        \n        return try await requestManager.performOptimizedRequest(\n            endpoint: \"/api/ai/sessions/create\",\n            method: .POST,\n            body: requestData\n        )\n    }\n    \n    // MARK: - Memory Management\n    \n    private func handleMemoryPressure() {\n        // Clear non-essential caches\n        cache.removeAllCachedResponses()\n        requestManager.clearRequestCache()\n        \n        // Reset connection pool\n        requestManager.resetConnectionPool()\n    }\n    \n    deinit {\n        NotificationCenter.default.removeObserver(self)\n    }\n}\n\n// MARK: - Advanced Request Manager\n\nclass RequestManager {\n    private var session: URLSession!\n    private var requestCache: [String: CachedRequest] = [:]\n    private let cacheQueue = DispatchQueue(label: \"com.studyai.request_cache\")\n    \n    func configure(with configuration: URLSessionConfiguration) {\n        session = URLSession(configuration: configuration)\n    }\n    \n    func performOptimizedRequest<T: Codable>(\n        endpoint: String,\n        method: HTTPMethod = .GET,\n        body: [String: Any]? = nil,\n        cachePolicy: URLRequest.CachePolicy = .useProtocolCachePolicy\n    ) async throws -> T {\n        \n        let url = URL(string: \"https://sai-backend-production.up.railway.app\\(endpoint)\")!\n        var request = URLRequest(url: url, cachePolicy: cachePolicy)\n        request.httpMethod = method.rawValue\n        \n        // Add optimized headers\n        addOptimizedHeaders(to: &request)\n        \n        // Add body if needed\n        if let body = body {\n            request.httpBody = try JSONSerialization.data(withJSONObject: body)\n        }\n        \n        let (data, response) = try await session.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              200...299 ~= httpResponse.statusCode else {\n            throw NetworkError.invalidResponse\n        }\n        \n        return try JSONDecoder().decode(T.self, from: data)\n    }\n    \n    func performMultipartUpload(\n        endpoint: String,\n        imageData: Data,\n        parameters: [String: String]\n    ) async throws -> [String: Any] {\n        \n        let url = URL(string: \"https://sai-backend-production.up.railway.app\\(endpoint)\")!\n        let boundary = \"StudyAI-\\(UUID().uuidString)\"\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = \"POST\"\n        request.setValue(\"multipart/form-data; boundary=\\(boundary)\", forHTTPHeaderField: \"Content-Type\")\n        \n        addOptimizedHeaders(to: &request)\n        \n        // Create optimized multipart data\n        let formData = createOptimizedMultipartData(imageData: imageData, parameters: parameters, boundary: boundary)\n        request.httpBody = formData\n        \n        let (data, response) = try await session.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              200...299 ~= httpResponse.statusCode else {\n            throw NetworkError.invalidResponse\n        }\n        \n        return try JSONSerialization.jsonObject(with: data) as? [String: Any] ?? [:]\n    }\n    \n    private func addOptimizedHeaders(to request: inout URLRequest) {\n        if let token = AuthenticationService.shared.getAuthToken() {\n            request.setValue(\"Bearer \\(token)\", forHTTPHeaderField: \"Authorization\")\n        }\n        \n        request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        request.setValue(\"StudyAI-iOS/2.0-Optimized\", forHTTPHeaderField: \"User-Agent\")\n        request.setValue(\"gzip, deflate, br\", forHTTPHeaderField: \"Accept-Encoding\")\n        request.setValue(\"keep-alive\", forHTTPHeaderField: \"Connection\")\n    }\n    \n    private func createOptimizedMultipartData(imageData: Data, parameters: [String: String], boundary: String) -> Data {\n        var formData = Data()\n        \n        // Add parameters\n        for (key, value) in parameters {\n            formData.append(\"--\\(boundary)\\r\\n\".data(using: .utf8)!)\n            formData.append(\"Content-Disposition: form-data; name=\\\"\\(key)\\\"\\r\\n\\r\\n\".data(using: .utf8)!)\n            formData.append(\"\\(value)\\r\\n\".data(using: .utf8)!)\n        }\n        \n        // Add image with optimal compression\n        formData.append(\"--\\(boundary)\\r\\n\".data(using: .utf8)!)\n        formData.append(\"Content-Disposition: form-data; name=\\\"image\\\"; filename=\\\"homework.jpg\\\"\\r\\n\".data(using: .utf8)!)\n        formData.append(\"Content-Type: image/jpeg\\r\\n\\r\\n\".data(using: .utf8)!)\n        formData.append(imageData)\n        formData.append(\"\\r\\n--\\(boundary)--\\r\\n\".data(using: .utf8)!)\n        \n        return formData\n    }\n    \n    func clearRequestCache() {\n        cacheQueue.async {\n            self.requestCache.removeAll()\n        }\n    }\n    \n    func resetConnectionPool() {\n        session.invalidateAndCancel()\n        // Session will be recreated on next request\n    }\n}\n\n// MARK: - Supporting Types\n\nenum HTTPMethod: String {\n    case GET, POST, PUT, DELETE, PATCH\n}\n\nenum NetworkError: LocalizedError {\n    case invalidResponse\n    case noData\n    case decodingError\n    \n    var errorDescription: String? {\n        switch self {\n        case .invalidResponse: return \"Invalid server response\"\n        case .noData: return \"No data received\"\n        case .decodingError: return \"Failed to decode response\"\n        }\n    }\n}\n\nstruct CachedRequest {\n    let response: Data\n    let timestamp: Date\n    let expiresAt: Date\n}\n\nstruct QuestionResponse: Codable {\n    let answer: String\n    let confidence: Double\n    let processingTime: Double\n}\n\nstruct SessionCreationResponse: Codable {\n    let sessionId: String\n    let message: String\n    let userId: String\n}\n\n// MARK: - Image Processor\n\nclass ImageProcessor {\n    static let shared = ImageProcessor()\n    \n    func optimizeForUpload(_ imageData: Data) async -> Data {\n        return await withCheckedContinuation { continuation in\n            DispatchQueue.global(qos: .userInitiated).async {\n                guard let image = UIImage(data: imageData) else {\n                    continuation.resume(returning: imageData)\n                    return\n                }\n                \n                // Optimize size and quality\n                let maxSize: CGFloat = 2048\n                let compressionQuality: CGFloat = 0.8\n                \n                let optimizedImage = self.resizeImage(image, maxSize: maxSize)\n                let optimizedData = optimizedImage.jpegData(compressionQuality: compressionQuality) ?? imageData\n                \n                continuation.resume(returning: optimizedData)\n            }\n        }\n    }\n    \n    private func resizeImage(_ image: UIImage, maxSize: CGFloat) -> UIImage {\n        let size = image.size\n        let aspectRatio = size.width / size.height\n        \n        var newSize: CGSize\n        if size.width > size.height {\n            newSize = CGSize(width: maxSize, height: maxSize / aspectRatio)\n        } else {\n            newSize = CGSize(width: maxSize * aspectRatio, height: maxSize)\n        }\n        \n        let renderer = UIGraphicsImageRenderer(size: newSize)\n        return renderer.image { _ in\n            image.draw(in: CGRect(origin: .zero, size: newSize))\n        }\n    }\n}\n\n// MARK: - Response Processor\n\nclass ResponseProcessor {\n    func processResponse<T: Codable>(_ data: Data, as type: T.Type) throws -> T {\n        let decoder = JSONDecoder()\n        decoder.dateDecodingStrategy = .iso8601\n        return try decoder.decode(type, from: data)\n    }\n}\n\nlet imageProcessor = ImageProcessor.shared"