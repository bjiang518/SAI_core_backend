//\n//  ErrorManager.swift\n//  StudyAI\n//\n//  Comprehensive error handling and resilience system\n//\n\nimport Foundation\nimport os.log\n\n// MARK: - Error Types\n\nenum StudyAIError: LocalizedError, Codable {\n    case network(NetworkErrorDetails)\n    case authentication(AuthErrorDetails)\n    case parsing(ParsingErrorDetails)\n    case storage(StorageErrorDetails)\n    case ai(AIErrorDetails)\n    case validation(ValidationErrorDetails)\n    case unknown(String)\n    \n    var errorDescription: String? {\n        switch self {\n        case .network(let details):\n            return details.userFriendlyMessage\n        case .authentication(let details):\n            return details.userFriendlyMessage\n        case .parsing(let details):\n            return details.userFriendlyMessage\n        case .storage(let details):\n            return details.userFriendlyMessage\n        case .ai(let details):\n            return details.userFriendlyMessage\n        case .validation(let details):\n            return details.userFriendlyMessage\n        case .unknown(let message):\n            return \"An unexpected error occurred: \\(message)\"\n        }\n    }\n    \n    var recoverySuggestion: String? {\n        switch self {\n        case .network(let details):\n            return details.recoverySuggestion\n        case .authentication:\n            return \"Please sign in again to continue.\"\n        case .parsing:\n            return \"Please try again with a clearer image or different format.\"\n        case .storage:\n            return \"Please check your device storage and try again.\"\n        case .ai:\n            return \"Please try again in a moment. Our AI service may be temporarily busy.\"\n        case .validation:\n            return \"Please check your input and try again.\"\n        case .unknown:\n            return \"Please restart the app and try again.\"\n        }\n    }\n    \n    var isRetryable: Bool {\n        switch self {\n        case .network(let details):\n            return details.isRetryable\n        case .authentication:\n            return false\n        case .parsing:\n            return true\n        case .storage:\n            return true\n        case .ai:\n            return true\n        case .validation:\n            return false\n        case .unknown:\n            return true\n        }\n    }\n}\n\n// MARK: - Error Details\n\nstruct NetworkErrorDetails: Codable {\n    let type: NetworkErrorType\n    let statusCode: Int?\n    let userFriendlyMessage: String\n    let recoverySuggestion: String\n    let isRetryable: Bool\n    \n    enum NetworkErrorType: String, Codable {\n        case noConnection, timeout, serverError, rateLimited, invalidResponse\n    }\n}\n\nstruct AuthErrorDetails: Codable {\n    let type: AuthErrorType\n    let userFriendlyMessage: String\n    \n    enum AuthErrorType: String, Codable {\n        case tokenExpired, invalidCredentials, accountLocked, networkIssue\n    }\n}\n\nstruct ParsingErrorDetails: Codable {\n    let type: ParsingErrorType\n    let userFriendlyMessage: String\n    \n    enum ParsingErrorType: String, Codable {\n        case invalidFormat, imageQuality, unsupportedContent, aiProcessing\n    }\n}\n\nstruct StorageErrorDetails: Codable {\n    let type: StorageErrorType\n    let userFriendlyMessage: String\n    \n    enum StorageErrorType: String, Codable {\n        case insufficientSpace, permissionDenied, corruptedData, syncFailed\n    }\n}\n\nstruct AIErrorDetails: Codable {\n    let type: AIErrorType\n    let userFriendlyMessage: String\n    \n    enum AIErrorType: String, Codable {\n        case serviceUnavailable, quotaExceeded, processingFailed, invalidInput\n    }\n}\n\nstruct ValidationErrorDetails: Codable {\n    let field: String\n    let userFriendlyMessage: String\n}\n\n// MARK: - Error Manager\n\nclass ErrorManager: ObservableObject {\n    static let shared = ErrorManager()\n    \n    private let logger = Logger(subsystem: \"com.studyai\", category: \"ErrorManager\")\n    private let errorQueue = DispatchQueue(label: \"com.studyai.errors\", qos: .utility)\n    \n    // Error tracking\n    private var errorHistory: [ErrorEvent] = []\n    private let maxErrorHistory = 100\n    \n    // Retry management\n    private var retryAttempts: [String: Int] = [:]\n    private let maxRetryAttempts = 3\n    private let retryDelay: TimeInterval = 1.0\n    \n    private init() {\n        setupErrorTracking()\n    }\n    \n    private func setupErrorTracking() {\n        // Clear old error history periodically\n        Timer.scheduledTimer(withTimeInterval: 3600, repeats: true) { _ in\n            self.cleanupErrorHistory()\n        }\n    }\n    \n    // MARK: - Error Handling\n    \n    func handle<T>(\n        _ operation: @escaping () async throws -> T,\n        errorContext: String,\n        retryKey: String? = nil\n    ) async -> Result<T, StudyAIError> {\n        \n        let operationId = UUID().uuidString\n        \n        do {\n            let result = try await operation()\n            \n            // Reset retry count on success\n            if let retryKey = retryKey {\n                retryAttempts[retryKey] = 0\n            }\n            \n            return .success(result)\n            \n        } catch {\n            let studyAIError = mapToStudyAIError(error, context: errorContext)\n            \n            // Log error\n            logError(studyAIError, operationId: operationId, context: errorContext)\n            \n            // Handle retry logic\n            if let retryKey = retryKey, studyAIError.isRetryable {\n                let attempts = retryAttempts[retryKey, default: 0]\n                \n                if attempts < maxRetryAttempts {\n                    retryAttempts[retryKey] = attempts + 1\n                    \n                    logger.info(\"Retrying operation \\(retryKey), attempt \\(attempts + 1)\")\n                    \n                    // Exponential backoff\n                    let delay = retryDelay * pow(2.0, Double(attempts))\n                    try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))\n                    \n                    return await handle(operation, errorContext: errorContext, retryKey: retryKey)\n                }\n            }\n            \n            return .failure(studyAIError)\n        }\n    }\n    \n    private func mapToStudyAIError(_ error: Error, context: String) -> StudyAIError {\n        // Map various error types to StudyAIError\n        if let networkError = error as? URLError {\n            return mapURLError(networkError)\n        } else if let studyAIError = error as? StudyAIError {\n            return studyAIError\n        } else {\n            return .unknown(\"\\(context): \\(error.localizedDescription)\")\n        }\n    }\n    \n    private func mapURLError(_ error: URLError) -> StudyAIError {\n        let details: NetworkErrorDetails\n        \n        switch error.code {\n        case .notConnectedToInternet, .networkConnectionLost:\n            details = NetworkErrorDetails(\n                type: .noConnection,\n                statusCode: nil,\n                userFriendlyMessage: \"No internet connection available.\",\n                recoverySuggestion: \"Please check your internet connection and try again.\",\n                isRetryable: true\n            )\n        case .timedOut:\n            details = NetworkErrorDetails(\n                type: .timeout,\n                statusCode: nil,\n                userFriendlyMessage: \"The request timed out.\",\n                recoverySuggestion: \"Please check your connection and try again.\",\n                isRetryable: true\n            )\n        default:\n            details = NetworkErrorDetails(\n                type: .invalidResponse,\n                statusCode: nil,\n                userFriendlyMessage: \"Network request failed.\",\n                recoverySuggestion: \"Please try again in a moment.\",\n                isRetryable: true\n            )\n        }\n        \n        return .network(details)\n    }\n    \n    private func logError(_ error: StudyAIError, operationId: String, context: String) {\n        let errorEvent = ErrorEvent(\n            id: operationId,\n            error: error,\n            context: context,\n            timestamp: Date(),\n            deviceInfo: collectDeviceInfo()\n        )\n        \n        errorQueue.async {\n            self.errorHistory.append(errorEvent)\n            \n            // Keep history manageable\n            if self.errorHistory.count > self.maxErrorHistory {\n                self.errorHistory.removeFirst()\n            }\n        }\n        \n        logger.error(\"StudyAI Error: \\(error.localizedDescription ?? \"Unknown\"), Context: \\(context)\")\n    }\n    \n    private func collectDeviceInfo() -> DeviceInfo {\n        return DeviceInfo(\n            model: UIDevice.current.model,\n            systemVersion: UIDevice.current.systemVersion,\n            appVersion: Bundle.main.infoDictionary?[\"CFBundleShortVersionString\"] as? String ?? \"Unknown\",\n            memoryUsage: getCurrentMemoryUsage()\n        )\n    }\n    \n    private func getCurrentMemoryUsage() -> Double {\n        var info = mach_task_basic_info()\n        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4\n        \n        let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {\n            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {\n                task_info(mach_task_self_,\n                         task_flavor_t(MACH_TASK_BASIC_INFO),\n                         $0,\n                         &count)\n            }\n        }\n        \n        return kerr == KERN_SUCCESS ? Double(info.resident_size) / (1024 * 1024) : 0.0\n    }\n    \n    private func cleanupErrorHistory() {\n        errorQueue.async {\n            let cutoffDate = Date().addingTimeInterval(-86400) // 24 hours ago\n            self.errorHistory = self.errorHistory.filter { $0.timestamp > cutoffDate }\n        }\n    }\n    \n    // MARK: - Public Interface\n    \n    func getErrorReport() -> ErrorReport {\n        return errorQueue.sync {\n            return ErrorReport(\n                recentErrors: Array(errorHistory.suffix(10)),\n                totalErrors: errorHistory.count,\n                errorsByType: Dictionary(grouping: errorHistory, by: { type(of: $0.error) })\n                    .mapValues { $0.count }\n            )\n        }\n    }\n    \n    func clearErrorHistory() {\n        errorQueue.async {\n            self.errorHistory.removeAll()\n            self.retryAttempts.removeAll()\n        }\n    }\n}\n\n// MARK: - Supporting Types\n\nstruct ErrorEvent {\n    let id: String\n    let error: StudyAIError\n    let context: String\n    let timestamp: Date\n    let deviceInfo: DeviceInfo\n}\n\nstruct DeviceInfo {\n    let model: String\n    let systemVersion: String\n    let appVersion: String\n    let memoryUsage: Double // MB\n}\n\nstruct ErrorReport {\n    let recentErrors: [ErrorEvent]\n    let totalErrors: Int\n    let errorsByType: [String: Int]\n}\n\n// MARK: - Resilience Helpers\n\nextension ErrorManager {\n    \n    // Circuit breaker pattern implementation\n    func executeWithCircuitBreaker<T>(\n        _ operation: @escaping () async throws -> T,\n        circuitKey: String,\n        timeout: TimeInterval = 30.0\n    ) async -> Result<T, StudyAIError> {\n        \n        // Check if circuit is open\n        if isCircuitOpen(circuitKey) {\n            let error = StudyAIError.network(NetworkErrorDetails(\n                type: .serverError,\n                statusCode: nil,\n                userFriendlyMessage: \"Service is temporarily unavailable.\",\n                recoverySuggestion: \"Please try again in a few minutes.\",\n                isRetryable: true\n            ))\n            return .failure(error)\n        }\n        \n        return await handle({\n            try await withTimeout(timeout) {\n                try await operation()\n            }\n        }, errorContext: \"Circuit Breaker: \\(circuitKey)\", retryKey: circuitKey)\n    }\n    \n    private func isCircuitOpen(_ key: String) -> Bool {\n        let failures = retryAttempts[\"\\(key)_circuit\", default: 0]\n        return failures >= maxRetryAttempts\n    }\n    \n    private func withTimeout<T>(_ timeout: TimeInterval, operation: @escaping () async throws -> T) async throws -> T {\n        try await withThrowingTaskGroup(of: T.self) { group in\n            group.addTask {\n                try await operation()\n            }\n            \n            group.addTask {\n                try await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))\n                throw URLError(.timedOut)\n            }\n            \n            let result = try await group.next()!\n            group.cancelAll()\n            return result\n        }\n    }\n}"