//
//  DiagramRendererView.swift
//  StudyAI
//
//  Created by Claude Code for AI-generated diagram feature
//  Renders LaTeX/SVG diagrams generated by AI Engine
//

import SwiftUI
import WebKit

// MARK: - Diagram Renderer View

/// Main view for rendering AI-generated diagrams in chat messages
/// Supports both LaTeX/TikZ and SVG diagram formats
struct DiagramRendererView: View {
    let diagramType: String
    let diagramCode: String
    let diagramTitle: String?
    let renderingHint: NetworkService.DiagramRenderingHint?

    @State private var isLoading = true
    @State private var hasError = false
    @State private var errorMessage = ""
    @State private var renderedImage: UIImage?
    @State private var diagramScale: CGFloat = 1.0

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Diagram content (title and badge removed for cleaner display)
            Group {
                if hasError {
                    errorView
                } else if isLoading {
                    loadingView
                } else if let image = renderedImage {
                    renderedImageView(image: image)
                } else {
                    fallbackCodeView
                }
            }
            .frame(maxWidth: .infinity)
            .background(Color.gray.opacity(0.05))
            .cornerRadius(12)
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(Color.blue.opacity(0.2), lineWidth: 1)
            )
        }
        .onAppear {
            renderDiagram()
        }
    }

    // MARK: - Loading View

    private var loadingView: some View {
        VStack(spacing: 12) {
            ProgressView()
                .scaleEffect(0.8)

            Text("Rendering \(diagramType.uppercased()) diagram...")
                .font(.system(size: 12))
                .foregroundColor(.secondary)
        }
        .frame(height: 100)
        .frame(maxWidth: .infinity)
    }

    // MARK: - Error View

    private var errorView: some View {
        VStack(spacing: 8) {
            Image(systemName: "info.circle")
                .foregroundColor(.blue)
                .font(.system(size: 20))

            Text("Cannot Generate Diagram")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(.primary)

            Text(errorMessage)
                .font(.system(size: 12))
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 8)
        }
        .padding(16)
        .frame(maxWidth: .infinity)
    }

    // MARK: - Rendered Image View

    private func renderedImageView(image: UIImage) -> some View {
        ZStack {
            Image(uiImage: image)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .scaleEffect(diagramScale)
                .clipped()
        }
        .frame(maxHeight: calculateMaxHeight())
        .background(Color.white)
        .onTapGesture(count: 2) {
            // Double tap to reset zoom
            withAnimation(.spring()) {
                diagramScale = 1.0
            }
        }
        .gesture(
            MagnificationGesture()
                .onChanged { value in
                    diagramScale = max(0.5, min(3.0, value))
                }
        )
    }

    // MARK: - Fallback Code View

    private var fallbackCodeView: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: "code")
                    .foregroundColor(.gray)
                Text("Raw \(diagramType.uppercased()) Code")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(.secondary)
                Spacer()
            }

            ScrollView {
                Text(diagramCode)
                    .font(.system(size: 10, design: .monospaced))
                    .foregroundColor(.primary)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            .frame(maxHeight: 150)
        }
        .padding(12)
    }

    // MARK: - Diagram Rendering Logic

    private func renderDiagram() {
        Task {
            await MainActor.run {
                isLoading = true
                hasError = false
                errorMessage = ""
            }

            do {
                let image = try await renderDiagramImage()

                await MainActor.run {
                    renderedImage = image
                    isLoading = false
                }
            } catch {
                print("âŒ [DiagramRenderer] Rendering failed: \(error.localizedDescription)")

                await MainActor.run {
                    hasError = true
                    errorMessage = error.localizedDescription
                    isLoading = false
                }
            }
        }
    }

    private func renderDiagramImage() async throws -> UIImage {

        switch diagramType.lowercased() {
        case "matplotlib":
            print("ğŸ¨ [DiagramImage] â¡ï¸ Using Matplotlib renderer (base64 PNG)")
            return try MatplotlibRenderer.shared.renderMatplotlib(diagramCode)
        case "png":
            print("ğŸ¨ [DiagramImage] â¡ï¸ Using PNG renderer (base64 PNG from Graphviz)")
            return try MatplotlibRenderer.shared.renderPNG(diagramCode)
        case "latex", "tikz":
            print("ğŸ¨ [DiagramImage] â¡ï¸ Using LaTeX renderer")
            return try await LaTeXRenderer.shared.renderLaTeX(diagramCode, hint: renderingHint)
        case "svg":
            print("ğŸ¨ [DiagramImage] â¡ï¸ Using SVG renderer")
            return try await SVGRenderer.shared.renderSVG(diagramCode, hint: renderingHint)
        default:
            print("ğŸ¨ [DiagramImage] âŒ Unsupported format: \(diagramType)")
            throw DiagramError.unsupportedFormat(diagramType)
        }
    }

    private func calculateMaxHeight() -> CGFloat {
        if let hint = renderingHint {
            return CGFloat(hint.height)
        }
        return 300 // Default max height
    }
}

// MARK: - Matplotlib Renderer

/// Handles Matplotlib PNG diagram rendering (base64 decode only - no WebView needed!)
class MatplotlibRenderer {
    static let shared = MatplotlibRenderer()

    private init() {}

    func renderMatplotlib(_ base64PngCode: String) throws -> UIImage {
        print("ğŸ¨ [MatplotlibRenderer] Starting base64 PNG decode...")
        print("ğŸ¨ [MatplotlibRenderer] Code length: \(base64PngCode.count) characters")

        // Decode base64 string to Data
        guard let imageData = Data(base64Encoded: base64PngCode, options: .ignoreUnknownCharacters) else {
            print("ğŸ¨ [MatplotlibRenderer] âŒ Failed to decode base64 string")
            throw DiagramError.invalidCode("Invalid base64 PNG data from matplotlib")
        }

        print("ğŸ¨ [MatplotlibRenderer] âœ… Decoded \(imageData.count) bytes")

        // Create UIImage from data
        guard let image = UIImage(data: imageData) else {
            print("ğŸ¨ [MatplotlibRenderer] âŒ Failed to create UIImage from data")
            throw DiagramError.renderingFailed("Could not create image from matplotlib PNG data")
        }

        print("ğŸ¨ [MatplotlibRenderer] âœ… Created UIImage successfully")
        print("ğŸ¨ [MatplotlibRenderer] Image size: \(image.size.width)x\(image.size.height)")
        print("ğŸ¨ [MatplotlibRenderer] Image scale: \(image.scale)")

        return image
    }

    func renderPNG(_ dataURL: String) throws -> UIImage {
        print("ğŸ¨ [MatplotlibRenderer] Rendering PNG from data URL...")
        print("ğŸ¨ [MatplotlibRenderer] Data URL length: \(dataURL.count) characters")

        // Extract base64 data from data URL format: "data:image/png;base64,{base64_string}"
        let base64String: String
        if dataURL.hasPrefix("data:image/png;base64,") {
            base64String = String(dataURL.dropFirst("data:image/png;base64,".count))
            print("ğŸ¨ [MatplotlibRenderer] Extracted base64 from data URL")
        } else {
            // Assume it's already base64 without the data URL prefix
            base64String = dataURL
            print("ğŸ¨ [MatplotlibRenderer] Using string as-is (no data URL prefix)")
        }

        // Decode base64 string to Data
        guard let imageData = Data(base64Encoded: base64String, options: .ignoreUnknownCharacters) else {
            print("ğŸ¨ [MatplotlibRenderer] âŒ Failed to decode base64 string")
            throw DiagramError.invalidCode("Invalid base64 PNG data from Graphviz")
        }

        print("ğŸ¨ [MatplotlibRenderer] âœ… Decoded \(imageData.count) bytes")

        // Create UIImage from data
        guard let image = UIImage(data: imageData) else {
            print("ğŸ¨ [MatplotlibRenderer] âŒ Failed to create UIImage from data")
            throw DiagramError.renderingFailed("Could not create image from PNG data")
        }

        print("ğŸ¨ [MatplotlibRenderer] âœ… Created UIImage successfully")
        print("ğŸ¨ [MatplotlibRenderer] Image size: \(image.size.width)x\(image.size.height)")
        print("ğŸ¨ [MatplotlibRenderer] Image scale: \(image.scale)")

        return image
    }
}

// MARK: - LaTeX Renderer

/// Handles LaTeX/TikZ diagram rendering using MathJax or similar web-based rendering
class LaTeXRenderer {
    static let shared = LaTeXRenderer()

    // âœ… FIX: Retain active renderers until they complete
    private var activeRenderers: [String: LaTeXWebRenderer] = [:]
    private let queue = DispatchQueue(label: "latex.renderer.manager")

    private init() {}

    func renderLaTeX(_ code: String, hint: NetworkService.DiagramRenderingHint?) async throws -> UIImage {
        let continuationId = "LaTeX-\(UUID().uuidString.prefix(8))"

        print("ğŸ¨ [LaTeXRenderer] Starting LaTeX rendering...")
        print("ğŸ¨ [LaTeXRenderer] Code length: \(code.count) characters")
        print("ğŸ¨ [LaTeXRenderer] Continuation ID: \(continuationId)")
        if let hint = hint {
            print("ğŸ¨ [LaTeXRenderer] Size: \(hint.width)x\(hint.height)")
        }

        // For LaTeX rendering, we'll use a WebView with MathJax
        return try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.main.async {
                print("ğŸ¨ [LaTeXRenderer] Creating WebView renderer...")

                let renderer = LaTeXWebRenderer(
                    latexCode: code,
                    hint: hint,
                    completion: { [weak self] result in
                        print("ğŸ¨ [LaTeXRenderer] âœ… Renderer completion called for \(continuationId)")
                        continuation.resume(with: result)

                        // âœ… FIX: Remove renderer from active list after completion
                        self?.queue.async {
                            self?.activeRenderers.removeValue(forKey: continuationId)
                            print("ğŸ¨ [LaTeXRenderer] âœ… Removed renderer \(continuationId) from active list (count: \(self?.activeRenderers.count ?? 0))")
                        }
                    }
                )

                // âœ… FIX: Store renderer in active list to prevent deallocation
                self.queue.async {
                    self.activeRenderers[continuationId] = renderer
                    print("ğŸ¨ [LaTeXRenderer] âœ… Stored renderer \(continuationId) in active list (count: \(self.activeRenderers.count))")
                }

                print("ğŸ¨ [LaTeXRenderer] WebView renderer created and started")
            }
        }
    }
}

// MARK: - Debug Logging Utility

class DiagramDebugLogger {
    static let shared = DiagramDebugLogger()
    private var activeContinuations: Set<String> = []
    private let queue = DispatchQueue(label: "diagram.debug.logger")

    private init() {}

    func logContinuationCreated(_ id: String) {
        queue.async {
            self.activeContinuations.insert(id)
            print("ğŸ” [DEBUG] Continuation CREATED: \(id)")
            print("ğŸ” [DEBUG] Active continuations: \(self.activeContinuations.count)")
        }
    }

    func logContinuationResumed(_ id: String) {
        queue.async {
            self.activeContinuations.remove(id)
            print("ğŸ” [DEBUG] Continuation RESUMED: \(id)")
            print("ğŸ” [DEBUG] Active continuations: \(self.activeContinuations.count)")
        }
    }

    func logContinuationLeak(_ id: String) {
        queue.async {
            print("ğŸ” [DEBUG] âŒ Continuation LEAKED: \(id)")
            print("ğŸ” [DEBUG] All active: \(self.activeContinuations)")
        }
    }

    func getActiveContinuations() -> Int {
        return queue.sync { activeContinuations.count }
    }
}

// MARK: - SVG Renderer

/// Handles SVG diagram rendering using native iOS SVG capabilities
class SVGRenderer {
    static let shared = SVGRenderer()

    // âœ… FIX: Retain active renderers until they complete
    private var activeRenderers: [String: SVGImageRenderer] = [:]
    private let queue = DispatchQueue(label: "svg.renderer.manager")

    private init() {}

    func renderSVG(_ svgCode: String, hint: NetworkService.DiagramRenderingHint?) async throws -> UIImage {
        let continuationId = "SVG-\(UUID().uuidString.prefix(8))"
        DiagramDebugLogger.shared.logContinuationCreated(continuationId)

        print("ğŸ¨ [SVGRenderer] Starting SVG rendering...")
        print("ğŸ¨ [SVGRenderer] Code length: \(svgCode.count) characters")
        print("ğŸ¨ [SVGRenderer] Continuation ID: \(continuationId)")
        if let hint = hint {
            print("ğŸ¨ [SVGRenderer] Size: \(hint.width)x\(hint.height)")
        }

        return try await withCheckedThrowingContinuation { continuation in
            print("ğŸ” [DEBUG] withCheckedThrowingContinuation ENTERED for \(continuationId)")

            DispatchQueue.main.async {
                print("ğŸ¨ [SVGRenderer] Creating SVG renderer...")
                print("ğŸ” [DEBUG] About to create SVGImageRenderer with continuation \(continuationId)")

                let renderer = SVGImageRenderer(
                    svgCode: svgCode,
                    hint: hint,
                    continuationId: continuationId,  // Pass the ID for tracking
                    completion: { [weak self] result in
                        print("ğŸ” [DEBUG] SVGImageRenderer completion called for \(continuationId)")
                        DiagramDebugLogger.shared.logContinuationResumed(continuationId)
                        continuation.resume(with: result)
                        print("ğŸ” [DEBUG] continuation.resume(with:) called for \(continuationId)")

                        // âœ… FIX: Remove renderer from active list after completion
                        self?.queue.async {
                            self?.activeRenderers.removeValue(forKey: continuationId)
                            print("ğŸ¨ [SVGRenderer] âœ… Removed renderer \(continuationId) from active list (count: \(self?.activeRenderers.count ?? 0))")
                        }
                    }
                )

                // âœ… FIX: Store renderer in active list to prevent deallocation
                self.queue.async {
                    self.activeRenderers[continuationId] = renderer
                    print("ğŸ¨ [SVGRenderer] âœ… Stored renderer \(continuationId) in active list (count: \(self.activeRenderers.count))")
                }

                print("ğŸ¨ [SVGRenderer] Starting render process...")
                renderer.render()
            }
        }
    }
}

// MARK: - LaTeX Web Renderer

/// WebKit-based LaTeX renderer using MathJax
class LaTeXWebRenderer: NSObject, WKNavigationDelegate {
    private let webView: WKWebView
    private let completion: (Result<UIImage, Error>) -> Void
    private let latexCode: String
    private let hint: NetworkService.DiagramRenderingHint?

    // âœ… FIX: Flag to prevent double completion call
    private var hasCompleted = false
    private let completionLock = NSLock()

    init(latexCode: String, hint: NetworkService.DiagramRenderingHint?, completion: @escaping (Result<UIImage, Error>) -> Void) {
        self.latexCode = latexCode
        self.hint = hint
        self.completion = completion

        let config = WKWebViewConfiguration()
        self.webView = WKWebView(frame: .zero, configuration: config)

        super.init()

        webView.navigationDelegate = self
        setupWebView()
    }

    private func setupWebView() {
        let width = hint?.width ?? 400
        let height = hint?.height ?? 300

        print("ğŸ¨ [LaTeXWebRenderer] Setting up WebView: \(width)x\(height)")
        webView.frame = CGRect(x: 0, y: 0, width: width, height: height)

        let htmlContent = generateHTMLForLaTeX()
        print("ğŸ¨ [LaTeXWebRenderer] HTML content length: \(htmlContent.count) characters")
        print("ğŸ¨ [LaTeXWebRenderer] Loading HTML content...")
        webView.loadHTMLString(htmlContent, baseURL: nil)
    }

    private func generateHTMLForLaTeX() -> String {
        let backgroundColor = hint?.background ?? "white"

        return """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
            <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
            <script>
                window.MathJax = {
                    tex: {
                        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']],
                        displayMath: [['$$', '$$'], ['\\\\[', '\\\\]']],
                        packages: ['base', 'ams', 'noerrors', 'noundefined', 'bbox']
                    },
                    svg: {
                        fontCache: 'global'
                    },
                    startup: {
                        ready: function () {
                            MathJax.startup.defaultReady();
                            MathJax.startup.promise.then(function () {
                                setTimeout(function() {
                                    window.webkit.messageHandlers.renderComplete.postMessage('ready');
                                }, 100);
                            });
                        }
                    }
                };
            </script>
            <style>
                body {
                    margin: 0;
                    padding: 20px;
                    background-color: \(backgroundColor);
                    font-family: 'Computer Modern', serif;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    min-height: calc(100vh - 40px);
                }
                .diagram-container {
                    text-align: center;
                    max-width: 100%;
                }
            </style>
        </head>
        <body>
            <div class="diagram-container">
                $$\(latexCode)$$
            </div>
        </body>
        </html>
        """
    }

    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        print("ğŸ¨ [LaTeXWebRenderer] WebView finished loading HTML")

        // Add message handler for render completion
        let script = WKUserScript(
            source: "window.webkit.messageHandlers.renderComplete.postMessage('loaded');",
            injectionTime: .atDocumentEnd,
            forMainFrameOnly: true
        )
        webView.configuration.userContentController.addUserScript(script)
        webView.configuration.userContentController.add(self, name: "renderComplete")

        print("ğŸ¨ [LaTeXWebRenderer] Added MathJax message handler")

        // Capture the rendered content after a delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            print("ğŸ¨ [LaTeXWebRenderer] Starting snapshot capture (fallback)")
            self.captureWebViewImage()
        }
    }

    func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
        print("ğŸ¨ [LaTeXWebRenderer] âŒ Navigation failed: \(error.localizedDescription)")
        completeOnce(with: .failure(error))
    }

    // âœ… FIX: Thread-safe completion wrapper to prevent double resume
    private func completeOnce(with result: Result<UIImage, Error>) {
        completionLock.lock()
        defer { completionLock.unlock() }

        guard !hasCompleted else {
            print("âš ï¸ [LaTeXWebRenderer] Completion already called - ignoring duplicate call")
            return
        }

        hasCompleted = true
        print("ğŸ¨ [LaTeXWebRenderer] Calling completion (first time)")
        completion(result)
    }

    private func captureWebViewImage() {
        print("ğŸ¨ [LaTeXWebRenderer] === STARTING WEBVIEW IMAGE CAPTURE ===")
        print("ğŸ¨ [LaTeXWebRenderer] Taking WebView snapshot...")
        print("ğŸ¨ [LaTeXWebRenderer] WebView frame: \(webView.frame)")
        print("ğŸ¨ [LaTeXWebRenderer] WebView content size: \(webView.scrollView.contentSize)")

        webView.takeSnapshot(with: nil) { [weak self] image, error in
            print("ğŸ¨ [LaTeXWebRenderer] === SNAPSHOT RESULT RECEIVED ===")

            if let image = image {
                print("ğŸ¨ [LaTeXWebRenderer] âœ… Snapshot captured successfully")
                print("ğŸ¨ [LaTeXWebRenderer] - Image size: \(image.size)")
                print("ğŸ¨ [LaTeXWebRenderer] - Image scale: \(image.scale)")
                print("ğŸ¨ [LaTeXWebRenderer] - Total pixels: \(Int(image.size.width * image.size.height))")
                print("ğŸ¨ [LaTeXWebRenderer] Calling completeOnce(.success)")
                self?.completeOnce(with: .success(image))
            } else if let error = error {
                print("ğŸ¨ [LaTeXWebRenderer] âŒ Snapshot failed with error")
                print("ğŸ¨ [LaTeXWebRenderer] - Error type: \(type(of: error))")
                print("ğŸ¨ [LaTeXWebRenderer] - Error description: \(error.localizedDescription)")
                print("ğŸ¨ [LaTeXWebRenderer] Calling completeOnce(.failure) with error")
                self?.completeOnce(with: .failure(error))
            } else {
                print("ğŸ¨ [LaTeXWebRenderer] âŒ Snapshot failed with no error information")
                print("ğŸ¨ [LaTeXWebRenderer] This is an unexpected state - no image and no error")
                print("ğŸ¨ [LaTeXWebRenderer] Calling completeOnce(.failure) with generic error")
                self?.completeOnce(with: .failure(DiagramError.renderingFailed("Unknown error during LaTeX rendering")))
            }

            print("ğŸ¨ [LaTeXWebRenderer] === LATEX RENDERING COMPLETE ===")
        }

        print("ğŸ¨ [LaTeXWebRenderer] Snapshot capture request submitted to WebView")
    }
}

// MARK: - WKScriptMessageHandler Extension

extension LaTeXWebRenderer: WKScriptMessageHandler {
    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        print("ğŸ¨ [LaTeXWebRenderer] Received message: '\(message.name)' = '\(message.body)'")

        if message.name == "renderComplete" {
            print("ğŸ¨ [LaTeXWebRenderer] MathJax rendering completed")
            // MathJax has finished rendering
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                print("ğŸ¨ [LaTeXWebRenderer] Starting snapshot capture (MathJax ready)")
                self.captureWebViewImage()
            }
        }
    }
}

// MARK: - SVG Image Renderer

/// Native iOS SVG renderer
class SVGImageRenderer: NSObject {
    private let svgCode: String
    private let hint: NetworkService.DiagramRenderingHint?
    private let completion: (Result<UIImage, Error>) -> Void
    private let continuationId: String
    private var webView: WKWebView?
    private var timeoutTimer: Timer?
    private var hasCompleted = false

    init(svgCode: String, hint: NetworkService.DiagramRenderingHint?, continuationId: String, completion: @escaping (Result<UIImage, Error>) -> Void) {
        self.svgCode = svgCode
        self.hint = hint
        self.completion = completion
        self.continuationId = continuationId
        super.init()
    }

    deinit {
        if !hasCompleted {
            DiagramDebugLogger.shared.logContinuationLeak(continuationId)
        }
    }

    func render() {
        guard !hasCompleted else {
            return
        }

        DispatchQueue.main.async {
            self.renderSVGWithWebView()
        }
    }

    private func renderSVGWithWebView() {
        let width = hint?.width ?? 400
        let height = hint?.height ?? 300

        let config = WKWebViewConfiguration()
        config.websiteDataStore = WKWebsiteDataStore.nonPersistent()
        config.suppressesIncrementalRendering = false
        config.allowsInlineMediaPlayback = true

        webView = WKWebView(frame: CGRect(x: 0, y: 0, width: width, height: height), configuration: config)
        webView?.navigationDelegate = self

        let htmlContent = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <style>
                body {
                    margin: 0;
                    padding: 20px;
                    background-color: \(hint?.background ?? "white");
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    min-height: calc(100vh - 40px);
                    font-family: Arial, sans-serif;
                }
                svg {
                    max-width: 100%;
                    height: auto;
                }
                .svg-container {
                    text-align: center;
                    width: 100%;
                    height: 100%;
                }
                .debug-info {
                    position: fixed;
                    top: 5px;
                    right: 5px;
                    font-size: 8px;
                    background: rgba(0,0,0,0.1);
                    padding: 2px;
                }
            </style>
            <script>
                console.log('ğŸ¨ [WebView] HTML document loaded');
                window.addEventListener('load', function() {
                    console.log('ğŸ¨ [WebView] Window load event fired');
                    setTimeout(function() {
                        console.log('ğŸ¨ [WebView] SVG should be rendered by now');
                    }, 100);
                });

                window.addEventListener('DOMContentLoaded', function() {
                    console.log('ğŸ¨ [WebView] DOMContentLoaded fired');
                });
            </script>
        </head>
        <body>
            <div class="svg-container">
                \(svgCode)
            </div>
            <div class="debug-info">SVG-\(Int.random(in: 1000...9999))</div>
        </body>
        </html>
        """

        // Validate SVG
        let svgLower = svgCode.lowercased()
        if !svgLower.contains("<svg") {
            print("âŒ [SVGImageRenderer] Invalid SVG: missing <svg> tag")
            completeWithResult(image: nil, error: DiagramError.invalidCode("SVG content missing <svg> tag"))
            return
        }

        // Set up timeout timer
        timeoutTimer = Timer.scheduledTimer(withTimeInterval: 3.0, repeats: false) { [weak self] _ in
            self?.handleTimeout()
        }

        guard let webView = webView else {
            print("âŒ [SVGImageRenderer] WebView creation failed")
            completeWithResult(image: nil, error: DiagramError.renderingFailed("WebView creation failed"))
            return
        }

        webView.loadHTMLString(htmlContent, baseURL: nil)
    }

    private func captureSnapshot() {
        guard let webView = webView, !hasCompleted else {
            return
        }

        webView.takeSnapshot(with: nil) { [weak self] image, error in
            if let error = error {
                print("âŒ [SVGImageRenderer] Snapshot failed: \(error.localizedDescription)")
            }
            self?.completeWithResult(image: image, error: error)
        }
    }

    private func completeWithResult(image: UIImage?, error: Error?) {
        guard !hasCompleted else {
            return
        }

        hasCompleted = true

        if let error = error {
            print("âŒ [SVGRenderer] Rendering failed: \(error.localizedDescription)")
        }

        // Clean up timeout timer
        if let timer = timeoutTimer {
            timer.invalidate()
            timeoutTimer = nil
        }

        // Clear webView to prevent memory leaks
        if let webView = webView {
            webView.navigationDelegate = nil
            self.webView = nil
        }

        // Call completion with appropriate result
        if let image = image {
            completion(.success(image))
        } else if let error = error {
            completion(.failure(error))
        } else {
            completion(.failure(DiagramError.renderingFailed("Unknown error during SVG rendering")))
        }
    }

    private func handleTimeout() {
        guard !hasCompleted else {
            return
        }

        // Try alternative rendering approach as fallback
        attemptAlternativeRendering()
    }

    // NEW: Alternative rendering fallback
    private func attemptAlternativeRendering() {
        print("ğŸ¨ [SVGRenderer] === ATTEMPTING ALTERNATIVE RENDERING ===")
        print("ğŸ¨ [SVGRenderer] WebView-based rendering failed, trying alternative approach")

        guard !hasCompleted else {
            print("ğŸ¨ [SVGRenderer] âŒ Already completed, skipping alternative rendering")
            return
        }

        // Try to create a simple bitmap representation of basic SVG
        if let simpleImage = createBasicSVGFallbackImage() {
            print("ğŸ¨ [SVGRenderer] âœ… Created fallback bitmap image")
            print("ğŸ¨ [SVGRenderer] Fallback image size: \(simpleImage.size)")
            completeWithResult(image: simpleImage, error: nil)
        } else {
            print("ğŸ¨ [SVGRenderer] âŒ Alternative rendering also failed")
            completeWithResult(image: nil, error: DiagramError.renderingFailed("SVG rendering timeout - all methods failed"))
        }
    }

    // NEW: Create a basic fallback image for simple SVG content
    private func createBasicSVGFallbackImage() -> UIImage? {
        print("ğŸ¨ [SVGRenderer] === CREATING BASIC SVG FALLBACK IMAGE ===")

        let width = hint?.width ?? 400
        let height = hint?.height ?? 300
        let size = CGSize(width: CGFloat(width), height: CGFloat(height))

        print("ğŸ¨ [SVGRenderer] Creating fallback with size: \(size)")

        // Analyze SVG for basic shapes we can render
        let svgLower = svgCode.lowercased()

        let renderer = UIGraphicsImageRenderer(size: size)
        let image = renderer.image { context in
            let cgContext = context.cgContext

            // Set background color
            let backgroundColor = parseBackgroundColor()
            cgContext.setFillColor(backgroundColor)
            cgContext.fill(CGRect(origin: .zero, size: size))

            // Try to extract and render basic shapes
            if svgLower.contains("circle") {
                drawCircleFromSVG(in: cgContext, size: size)
            } else if svgLower.contains("rect") {
                drawRectFromSVG(in: cgContext, size: size)
            } else if svgLower.contains("line") {
                drawLineFromSVG(in: cgContext, size: size)
            } else {
                // Fallback: draw a placeholder
                drawPlaceholder(in: cgContext, size: size)
            }
        }

        print("ğŸ¨ [SVGRenderer] âœ… Fallback image created successfully")
        return image
    }

    private func parseBackgroundColor() -> CGColor {
        if let bg = hint?.background {
            switch bg.lowercased() {
            case "white": return UIColor.white.cgColor
            case "black": return UIColor.black.cgColor
            case "gray", "grey": return UIColor.gray.cgColor
            case "blue": return UIColor.blue.cgColor
            default: return UIColor.white.cgColor
            }
        }
        return UIColor.white.cgColor
    }

    private func drawCircleFromSVG(in context: CGContext, size: CGSize) {
        print("ğŸ¨ [SVGRenderer] Drawing basic circle fallback")

        context.setFillColor(UIColor.blue.cgColor)
        context.setStrokeColor(UIColor.systemBlue.cgColor)
        context.setLineWidth(2.0)

        let radius = min(size.width, size.height) * 0.3
        let center = CGPoint(x: size.width / 2, y: size.height / 2)
        let rect = CGRect(x: center.x - radius, y: center.y - radius, width: radius * 2, height: radius * 2)

        context.fillEllipse(in: rect)
        context.strokeEllipse(in: rect)
    }

    private func drawRectFromSVG(in context: CGContext, size: CGSize) {
        print("ğŸ¨ [SVGRenderer] Drawing basic rectangle fallback")

        context.setFillColor(UIColor.green.cgColor)
        context.setStrokeColor(UIColor.systemGreen.cgColor)
        context.setLineWidth(2.0)

        let rectSize = CGSize(width: size.width * 0.6, height: size.height * 0.4)
        let rect = CGRect(x: (size.width - rectSize.width) / 2,
                         y: (size.height - rectSize.height) / 2,
                         width: rectSize.width,
                         height: rectSize.height)

        context.fill(rect)
        context.stroke(rect)
    }

    private func drawLineFromSVG(in context: CGContext, size: CGSize) {
        print("ğŸ¨ [SVGRenderer] Drawing basic line fallback")

        context.setStrokeColor(UIColor.red.cgColor)
        context.setLineWidth(3.0)

        context.move(to: CGPoint(x: size.width * 0.2, y: size.height * 0.5))
        context.addLine(to: CGPoint(x: size.width * 0.8, y: size.height * 0.5))
        context.strokePath()
    }

    private func drawPlaceholder(in context: CGContext, size: CGSize) {
        print("ğŸ¨ [SVGRenderer] Drawing generic SVG placeholder")

        // Draw a border
        context.setStrokeColor(UIColor.lightGray.cgColor)
        context.setLineWidth(1.0)
        context.stroke(CGRect(origin: .zero, size: size).insetBy(dx: 10, dy: 10))

        // Draw "SVG" text
        let font = UIFont.systemFont(ofSize: 24, weight: .medium)
        let attrs: [NSAttributedString.Key: Any] = [
            .font: font,
            .foregroundColor: UIColor.gray
        ]

        let text = "SVG Diagram"
        let textSize = text.size(withAttributes: attrs)
        let textRect = CGRect(x: (size.width - textSize.width) / 2,
                             y: (size.height - textSize.height) / 2,
                             width: textSize.width,
                             height: textSize.height)

        text.draw(in: textRect, withAttributes: attrs)
    }
}

// MARK: - WKNavigationDelegate

extension SVGImageRenderer: WKNavigationDelegate {
    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
        print("ğŸ¨ [SVGRenderer] === NAVIGATION: DID START PROVISIONAL ===")
        print("ğŸ¨ [SVGRenderer] Navigation object: \(navigation?.description ?? "nil")")
        print("ğŸ¨ [SVGRenderer] WebView URL: \(webView.url?.absoluteString ?? "No URL")")
        print("ğŸ¨ [SVGRenderer] WebView loading: \(webView.isLoading)")
        print("ğŸ¨ [SVGRenderer] Expected next: didFinish or didFailProvisionalNavigation")
    }

    func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) {
        print("ğŸ¨ [SVGRenderer] === NAVIGATION: DID COMMIT ===")
        print("ğŸ¨ [SVGRenderer] Navigation committed successfully")
        print("ğŸ¨ [SVGRenderer] Navigation object: \(navigation?.description ?? "nil")")
        print("ğŸ¨ [SVGRenderer] WebView URL: \(webView.url?.absoluteString ?? "No URL")")
        print("ğŸ¨ [SVGRenderer] Expected next: didFinish")
    }

    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        print("ğŸ¨ [SVGRenderer] === NAVIGATION: DID FINISH (SUCCESS) ===")
        print("ğŸ¨ [SVGRenderer] ğŸ‰ WebView finished loading HTML content")
        print("ğŸ¨ [SVGRenderer] Navigation object: \(navigation?.description ?? "nil")")
        print("ğŸ¨ [SVGRenderer] WebView title: '\(webView.title ?? "No title")'")
        print("ğŸ¨ [SVGRenderer] WebView URL: \(webView.url?.absoluteString ?? "No URL")")
        print("ğŸ¨ [SVGRenderer] WebView loading: \(webView.isLoading)")
        print("ğŸ¨ [SVGRenderer] WebView content size: \(webView.scrollView.contentSize)")
        print("ğŸ¨ [SVGRenderer] Has completed: \(hasCompleted)")

        // Check if already completed
        if hasCompleted {
            print("ğŸ¨ [SVGRenderer] âš ï¸ Already completed, skipping snapshot")
            return
        }

        // Wait a bit for SVG to render, then capture
        print("ğŸ¨ [SVGRenderer] Scheduling snapshot capture in 0.5 seconds...")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            print("ğŸ¨ [SVGRenderer] â° 0.5 second delay elapsed, starting snapshot capture")
            self.captureSnapshot()
        }
    }

    func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
        print("ğŸ¨ [SVGRenderer] === NAVIGATION: DID FAIL (ERROR) ===")
        print("ğŸ¨ [SVGRenderer] âŒ WebView navigation failed")
        print("ğŸ¨ [SVGRenderer] Navigation object: \(navigation?.description ?? "nil")")
        print("ğŸ¨ [SVGRenderer] Error type: \(type(of: error))")
        print("ğŸ¨ [SVGRenderer] Error code: \((error as NSError).code)")
        print("ğŸ¨ [SVGRenderer] Error domain: \((error as NSError).domain)")
        print("ğŸ¨ [SVGRenderer] Error description: \(error.localizedDescription)")
        print("ğŸ¨ [SVGRenderer] Error user info: \((error as NSError).userInfo)")

        print("ğŸ¨ [SVGRenderer] Calling completion with navigation error...")
        completeWithResult(image: nil, error: error)
    }

    func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
        print("ğŸ¨ [SVGRenderer] === NAVIGATION: DID FAIL PROVISIONAL (ERROR) ===")
        print("ğŸ¨ [SVGRenderer] âŒ WebView provisional navigation failed")
        print("ğŸ¨ [SVGRenderer] This typically occurs during initial load setup")
        print("ğŸ¨ [SVGRenderer] Navigation object: \(navigation?.description ?? "nil")")
        print("ğŸ¨ [SVGRenderer] Error type: \(type(of: error))")
        print("ğŸ¨ [SVGRenderer] Error code: \((error as NSError).code)")
        print("ğŸ¨ [SVGRenderer] Error domain: \((error as NSError).domain)")
        print("ğŸ¨ [SVGRenderer] Error description: \(error.localizedDescription)")
        print("ğŸ¨ [SVGRenderer] Error user info: \((error as NSError).userInfo)")

        print("ğŸ¨ [SVGRenderer] Calling completion with provisional navigation error...")
        completeWithResult(image: nil, error: error)
    }

    // NEW: Add decidePolicyFor methods to catch navigation policy issues
    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        print("ğŸ¨ [SVGRenderer] === NAVIGATION POLICY: ACTION ===")
        print("ğŸ¨ [SVGRenderer] Navigation type: \(navigationAction.navigationType.rawValue)")
        print("ğŸ¨ [SVGRenderer] Request URL: \(navigationAction.request.url?.absoluteString ?? "nil")")
        print("ğŸ¨ [SVGRenderer] Source frame: \(navigationAction.sourceFrame.request.url?.absoluteString ?? "nil")")
        print("ğŸ¨ [SVGRenderer] Target frame: \(navigationAction.targetFrame?.request.url?.absoluteString ?? "nil")")
        print("ğŸ¨ [SVGRenderer] Allowing navigation...")
        decisionHandler(.allow)
    }

    func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -> Void) {
        print("ğŸ¨ [SVGRenderer] === NAVIGATION POLICY: RESPONSE ===")
        print("ğŸ¨ [SVGRenderer] Response URL: \(navigationResponse.response.url?.absoluteString ?? "nil")")
        print("ğŸ¨ [SVGRenderer] MIME type: \(navigationResponse.response.mimeType ?? "nil")")

        if let httpResponse = navigationResponse.response as? HTTPURLResponse {
            print("ğŸ¨ [SVGRenderer] HTTP status code: \(httpResponse.statusCode)")
            print("ğŸ¨ [SVGRenderer] HTTP headers: \(httpResponse.allHeaderFields)")
        }

        print("ğŸ¨ [SVGRenderer] Can show MIME type: \(navigationResponse.canShowMIMEType)")
        print("ğŸ¨ [SVGRenderer] Allowing response...")
        decisionHandler(.allow)
    }

    // NEW: Add WebView content process methods
    func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
        print("ğŸ¨ [SVGRenderer] === CRITICAL: WEB CONTENT PROCESS TERMINATED ===")
        print("ğŸ¨ [SVGRenderer] âŒ WebView content process was terminated")
        print("ğŸ¨ [SVGRenderer] This means the WebView renderer crashed")
        print("ğŸ¨ [SVGRenderer] Calling completion with process termination error...")
        completeWithResult(image: nil, error: DiagramError.renderingFailed("WebView content process terminated"))
    }
}

// MARK: - Diagram Errors

enum DiagramError: LocalizedError {
    case unsupportedFormat(String)
    case renderingFailed(String)
    case invalidCode(String)

    var errorDescription: String? {
        switch self {
        case .unsupportedFormat(let format):
            return "Unsupported diagram format: \(format)"
        case .renderingFailed(let reason):
            return "Diagram rendering failed: \(reason)"
        case .invalidCode(let reason):
            return "Invalid diagram code: \(reason)"
        }
    }
}

// MARK: - Preview

struct DiagramRendererView_Previews: PreviewProvider {
    static var previews: some View {
        ScrollView {
            VStack(spacing: 20) {
                // Matplotlib example (would be actual base64 PNG in production)
                DiagramRendererView(
                    diagramType: "matplotlib",
                    diagramCode: "iVBORw0KGgoAAAANSUhEUg...", // Placeholder base64
                    diagramTitle: "Quadratic Function y = xÂ² + 5x + 6",
                    renderingHint: NetworkService.DiagramRenderingHint(
                        width: 800,
                        height: 600,
                        background: "white",
                        scaleFactor: 1.0
                    )
                )

                // LaTeX example
                DiagramRendererView(
                    diagramType: "latex",
                    diagramCode: "\\begin{tikzpicture} \\draw (0,0) circle (1); \\end{tikzpicture}",
                    diagramTitle: "Simple Circle",
                    renderingHint: NetworkService.DiagramRenderingHint(
                        width: 300,
                        height: 200,
                        background: "white",
                        scaleFactor: 1.0
                    )
                )

                // SVG example
                DiagramRendererView(
                    diagramType: "svg",
                    diagramCode: "<svg width='200' height='200'><circle cx='100' cy='100' r='50' fill='blue'/></svg>",
                    diagramTitle: "SVG Circle",
                    renderingHint: nil
                )
            }
            .padding()
        }
    }
}